//
// JynxZ80 - Jonathan's Z80 Emulator - Initially for Camputers Lynx Emulation Project.
// Copyright (C) 2014  Jonathan Markland
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// 
//		jynx_emulator {at} yahoo {dot} com
// 


#pragma once

#include <stdint.h>

namespace JynxZ80
{


	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	//     RULES
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	namespace RowMasks
	{
		// When an opcode is AND-masked with 0x38, the following result values indicate which row it's on.
	
		enum Enum
		{
			Row0 = 0x00,
			Row1 = 0x08,
			Row2 = 0x10,
			Row3 = 0x18,
			Row4 = 0x20,
			Row5 = 0x28,
			Row6 = 0x30,
			Row7 = 0x38,
		};
	}


	INLINE_FUNCTION uint8_t GetColumnNumber( uint8_t opcodeByte )
	{
		// I organise the Z80 opcode space in rows of 8, so this returns the column based on that.
		return (opcodeByte & 7);
	}



	INLINE_FUNCTION RowMasks::Enum  GetRowMask( uint8_t opcodeByte )
	{
		// I organise the Z80 opcode space as 8*32, with the 32 rows divided into four "quarters" each with 8 rows.
		// This effectively returns the row within the quarter.
		return (RowMasks::Enum) (opcodeByte & 0x38);
	}



	INLINE_FUNCTION uint8_t GetRowIndexWithinColumnFromOpcode( uint8_t opcodeByte )
	{
		// Used for doing a "column" of eight instructions, eg: C3 CB D3 DB E3 EB F3 FB.
		// This shifts and masks the opcode so it can be switched, with switch-cases of 0,1,2,3,4,5,6,7 resp.
		// This should result in a dispatch table being generated by the compiler.
		// Also used for other purposes requiring a mapping to 0-7.
		return (opcodeByte >> 3) & 7;
	}





	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	//     FLAGS
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	INLINE_FUNCTION   uint8_t  CalcZeroAndSignFlags( uint8_t value )
	{
		return (value == 0) ? Z80Flags::ZF : (value & Z80Flags::SF);
	}



	INLINE_FUNCTION   uint8_t  Z80::ZeroSignAndParity8( uint8_t value ) // static
	{
		return _signParityAndZeroTable[ value ];
	}



	INLINE_FUNCTION   uint8_t  CarryFlagFromBit16( uint32_t value )
	{
		return (value >> 16) & Z80Flags::CF;
	}



	INLINE_FUNCTION   uint8_t  SignAndZeroFlagFrom16BitNumber( uint16_t value )
	{
		// Bit 15 has the sign flag, we shift it into bit 7.
		return ((value == 0) ? Z80Flags::ZF : 0)   |   ((value >> 8) & Z80Flags::SF);
	}



	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	//     OVERFLOW CALCULATIONS
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

			// With thanks:
			// http://teaching.idallen.com/dat2343/10f/notes/040_overflow.txt

	INLINE_FUNCTION   uint32_t  CalcOverflowForAdd( uint32_t a, uint32_t b, uint32_t calculatedResult )
	{
		return ~(a ^ b) & (b ^ calculatedResult);
	}


	INLINE_FUNCTION   uint32_t  CalcOverflowForSubtract( uint32_t a, uint32_t b, uint32_t calculatedResult )
	{
		return (a ^ b) & (b ^ calculatedResult);
	}


	INLINE_FUNCTION   uint8_t  ShiftBit7IntoOverflowFlagPosition( uint8_t value )
	{
		// After the sub-expression, bit 7 has the desired V flag value, 
		// so we shift it into the Z80Flags::PV position:
		return (value >> 5) & Z80Flags::PV;
	}


	INLINE_FUNCTION   uint8_t  ShiftBit15IntoOverflowFlagPosition( uint16_t value )
	{
		// After the sub-expression, bit 15 has the desired V flag value, 
		// so we shift it into the Z80Flags::PV position:
		return (value >> 13) & Z80Flags::PV;
	}




	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	//    CALC Z80 OVERFLOW FLAG AFTER OPERATIONS
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	template<typename A, typename B, typename RESULT>
	INLINE_FUNCTION   uint8_t  OverflowFlagAfterAddition8( A a, B b, RESULT calculatedResult )
	{
		return ShiftBit7IntoOverflowFlagPosition( CalcOverflowForAdd( a, b, calculatedResult ) );
	}


	template<typename A, typename B, typename RESULT>
	INLINE_FUNCTION   uint8_t  OverflowFlagAfterSubtraction8( A a, B b, RESULT calculatedResult )
	{
		return ShiftBit7IntoOverflowFlagPosition( CalcOverflowForSubtract( a, b, calculatedResult ) );
	}


	template<typename A, typename B, typename RESULT>
	INLINE_FUNCTION   uint8_t  OverflowFlagAfterAddition16( A a, B b, RESULT calculatedResult )
	{
		return ShiftBit15IntoOverflowFlagPosition( CalcOverflowForAdd( a, b, calculatedResult ) );
	}


	template<typename A, typename B, typename RESULT>
	INLINE_FUNCTION   uint8_t  OverflowFlagAfterSubtraction16( A a, B b, RESULT calculatedResult )
	{
		return ShiftBit15IntoOverflowFlagPosition( CalcOverflowForSubtract( a, b, calculatedResult ) );
	}





	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	//    CALC Z80 HALF-CARRY FLAG AFTER OPERATIONS
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	template<typename A, typename B, typename RESULT>
	INLINE_FUNCTION   uint8_t  CarryAfterAddOrSubtract8( A a, B b, RESULT calculatedResult )
	{
		return ((a ^ b ^ calculatedResult) >> 8) & Z80Flags::CF;
	}


	template<typename A, typename B, typename RESULT>
	INLINE_FUNCTION   uint8_t  HalfCarryAfterAddOrSubtract8( A a, B b, RESULT calculatedResult )
	{
		return (a ^ b ^ calculatedResult) & Z80Flags::HF;
	}


	template<typename A, typename B, typename RESULT>
	INLINE_FUNCTION   uint8_t  HalfCarryAfterAddOrSubtract16( A a, B b, RESULT calculatedResult )
	{
		return ((a ^ b ^ calculatedResult) >> 8) & Z80Flags::HF;
	}




	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	//     CONDITION TESTING
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 



	extern ConditionTestingData  ConditionalExecutionMasksAndExpectations[8]; // Not to be used directly, use functions.



	INLINE_FUNCTION const ConditionTestingData &GetConditionTestingDataForRow( uint8_t opcodeByte )
	{
		return ConditionalExecutionMasksAndExpectations[ GetRowIndexWithinColumnFromOpcode( opcodeByte ) ];
	}



	INLINE_FUNCTION uint8_t  Z80::IsConditionSatisfied( const ConditionTestingData &conditionTestingData )  // To ensure performance, returns C-language style boolean.
	{
		return (Flags() & conditionTestingData.AndMask) ^ conditionTestingData.XorMask;  // return C-language boolean.  (== 0) means FALSE, (!= 0) means TRUE.
	}



	INLINE_FUNCTION uint8_t  Z80::IsConditionSatisfiedBasedOnOpcode()  // To ensure performance, returns C-language style boolean.
	{
		return IsConditionSatisfied( GetConditionTestingDataForRow( _currentOpcode ) );
	}




	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
	//     Z80 REGISTER SELECTION
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

	INLINE_FUNCTION uint16_t &Z80::GetReferenceTo_HL_IX_IY()
	{
		// This helps an instruction choose the correct 16-bit register uint16_t to read/write.
		// - If present, the DD and FD prefixes will have re-directed the HL slot to IX / IY, respectively.
		return *(_addressesOf16BitRegisterPairs_BC_DE_HL_AF[2]);
	}



	INLINE_FUNCTION uint16_t &Z80::GetReferenceTo_BC_DE_HLIXIY_SP_FromOpcodeBits5and4()
	{
		// This helps an instruction choose the correct 16-bit register uint16_t to read/write.
		// - If present, the DD and FD prefixes will have re-directed the HL slot to IX / IY, respectively.
		return *_addressesOf16BitRegisterPairs_BC_DE_HL_SP[ (_currentOpcode & 0x30) >> 4 ];
	}



	INLINE_FUNCTION uint16_t &Z80::GetReferenceToRegisterForPushPopGroupFromOpcode()
	{
		// This helps an instruction choose the correct 16-bit register uint16_t to read/write.
		// - If present, the DD and FD prefixes will have re-directed the HL slot to IX / IY, respectively.
		return *_addressesOf16BitRegisterPairs_BC_DE_HL_AF[ (_currentOpcode & 0x30) >> 4 ];
	}



	INLINE_FUNCTION uint8_t &Z80::GetReferenceToReg8_FromBits2to0OfOpcode()
	{
		// This helps an instruction choose the correct 8-bit register to read/write.
		// - If present, the DD prefix will have re-directed H to IXH, and L to IXL.
		// - If present, the FD prefix will have re-directed H to IYH, and L to IYL.
		// - Register 6 is the temporary holding register used with indirect instruction forms (HL) / (IX+dd) / (IY+dd)
		return *_addressesOf8BitRegisters[ _currentOpcode & 0x07 ];
	}



	INLINE_FUNCTION uint8_t &Z80::GetReferenceToReg8_NoRedirection_FromBits2to0OfOpcode()
	{
		// This helps an instruction choose the correct 8-bit register to read/write.
		// - The DD and FD prefixes have no effect: H and L will always reference H and L.
		// - Register 6 is the temporary holding register used with indirect instruction forms (HL) / (IX+dd) / (IY+dd)
		return *_addressesOf8BitRegisters_NoRedirection[ _currentOpcode & 0x07 ];
	}



	INLINE_FUNCTION uint8_t &Z80::GetReferenceToReg8_FromBits5to3()
	{
		// This helps an instruction choose the correct 8-bit register to read/write.
		// - If present, the DD prefix will have re-directed H to IXH, and L to IXL.
		// - If present, the FD prefix will have re-directed H to IYH, and L to IYL.
		// - Register 6 is the temporary holding register used with indirect instruction forms (HL) / (IX+dd) / (IY+dd)
		return *_addressesOf8BitRegisters[ (_currentOpcode & 0x38) >> 3 ];
	}



	INLINE_FUNCTION uint8_t &Z80::GetReferenceToReg8_NoRedirection_FromBits5to3()
	{
		// This helps an instruction choose the correct 8-bit register to read/write.
		// - The DD and FD prefixes have no effect: H and L will always reference H and L.
		// - Register 6 is the temporary holding register used with indirect instruction forms (HL) / (IX+dd) / (IY+dd)
		return *_addressesOf8BitRegisters_NoRedirection[ (_currentOpcode & 0x38) >> 3 ];
	}



} // end namespace
